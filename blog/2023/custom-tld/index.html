<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Custom TLD Over Tailscale | Andrew M. Zhang</title>
    <meta name="author" content="Andrew M. Zhang">
    <meta name="description" content="Pretending to be a legit enterprise with my own TLD">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://andrewmzhang.com/blog/2023/custom-tld/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Andrew </span>M. Zhang</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">AndyTechTips<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Custom TLD Over Tailscale</h1>
    <p class="post-meta">May 17, 2023• Andrew M. Zhang</p>
    <p class="post-tags">
      <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>
        ·  
        <a href="/blog/tag/andywebservices">
          <i class="fas fa-hashtag fa-sm"></i> AndyWebServices</a>  
          <a href="/blog/tag/tailscale">
          <i class="fas fa-hashtag fa-sm"></i> Tailscale</a>  
          <a href="/blog/tag/network">
          <i class="fas fa-hashtag fa-sm"></i> network</a>  
          
        ·  
        <a href="/blog/category/tech">
          <i class="fas fa-tag fa-sm"></i> tech</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="markdown-content">
      <p>Note: It’s like 2am and I was too sleepy to edit this, so I fed it through chatGPT and called it a day. I think it
made some minor mistakes and poor word choice. I’ll fix it tomorrow or something…</p>

<h1 id="intro">Intro</h1>

<p>Tailscale is a Wireguard-based VPN software that I rely on for secure and remote access across my devices. I appreciate
its remarkably minimal setup process - simply installing Tailscale on a device grants it access to the VPN, with the
software taking care of the rest. However, one inconvenience I encountered was the built-in DNS’s limitation of
resolving device hostnames without a TLD. For instance, if I add a machine with the hostname machineA, I can access
webpages hosted on it via https://machineA, but unfortunately, Tailscale DNS does not support setting the domain to
something like https://machineA.ctld. This page documents my solution to implementing a private TLD over a Tailscale
network.</p>

<p>I am committed to using TLS because I value the green lock symbol and the assurance it provides. It is crucial for my
setup to appear legitimate; otherwise, people may doubt the credibility of AndyWebServices El El Sí as a legitimate
company. This credibility is essential for attracting investors and achieving a valuation of 100 trillion.</p>

<p>To clarify. These are the requirements:</p>

<ul>
  <li>Any and only devices connected by my Tailscale network should be able to access the custom tld network</li>
  <li>I intend to use a custom TLD format, such as hostname.ctld. For the purpose of this guide, I will use .ctld as the
TLD.</li>
  <li>HTTPS functionality</li>
</ul>

<h1 id="resolving-a-custom-tld-over-tailscale">Resolving a custom TLD over Tailscale</h1>

<h2 id="resolving-custom-tld">Resolving custom TLD</h2>

<p>Tailscale facilitates secure connections between devices within the Tailscale network. Each device on the Tailscale
network is assigned a static Tailscale IP (100.xx.yy.zz) along with a non-TLD domain. The resolution of this non-TLD
domain is handled by a local DNS resolver that is included with the Tailscale installation.</p>

<p>To incorporate a custom TLD into this setup, the first step is to set up a dedicated DNS server to resolve <code class="language-plaintext highlighter-rouge">*.ctld</code>
domains. I recommend following the setup outlined below:</p>

<ol>
  <li>Obtain a Raspberry Pi device.
    <ol>
      <li>If you intend to replicate my network setup, install and configure Ubuntu on the Raspberry Pi.</li>
    </ol>
  </li>
  <li>Connect the Raspberry Pi to the Tailscale (TS) network. For the sake of this guide, let’s assume it is assigned the
TS IP address <code class="language-plaintext highlighter-rouge">100.100.100.101</code>.</li>
  <li>Install and set up <code class="language-plaintext highlighter-rouge">dnsmasq</code> on the Raspberry Pi.</li>
  <li>Edit the <code class="language-plaintext highlighter-rouge">/etc/hosts</code> file on the Raspberry Pi to manually define the DNS entries.
    <ol>
      <li>In case you are using the default Ubuntu installation, you may need to modify the cloud-init template. Please
refer to the comments in your <code class="language-plaintext highlighter-rouge">/etc/hosts</code> file for guidance.</li>
      <li>The entries in the <code class="language-plaintext highlighter-rouge">/etc/hosts</code> file should resemble the following format:</li>
    </ol>
  </li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /etc/hosts</span>
<span class="c"># tailscale_IP hostname</span>
myMachineA.ctld 100.100.100.123
</code></pre></div></div>

<p>You only need to perform this setup once since the Tailscale IP is static. Keep in mind that these IPs are only
accessible when connected to the VPN. While it is advisable to configure <code class="language-plaintext highlighter-rouge">dnsmasq</code> on your Tailscale network interface,
setting it up on <code class="language-plaintext highlighter-rouge">0.0.0.0</code> is unlikely to pose a security risk.</p>

<h2 id="splitdns">SplitDNS</h2>

<p>We must ensure the proper utilization of the DNS server by devices connected to the Tailscale network. To achieve
this, we will proceed with configuring SplitDNS within the Tailscale Admin Console. Our primary objective is to
establish the resolution of <code class="language-plaintext highlighter-rouge">*.ctld</code> to the Tailscale IP address assigned to the DNS server,
specifically <code class="language-plaintext highlighter-rouge">100.100.100.101</code>.</p>

<p>By implementing this approach, any device that joins the Tailscale Network will seamlessly attempt to utilize the DNS
resolver of the Raspberry Pi (rpi) running dnsmasq, but solely for domains associated with our custom top-level domain (
<code class="language-plaintext highlighter-rouge">ctld</code>). This strategy ensures optimal efficiency, as domain resolutions for standard domains like <code class="language-plaintext highlighter-rouge">google.com</code> continue
to
be handled by the local DNS, while requests for <code class="language-plaintext highlighter-rouge">*.ctld</code> domains are routed through the Tailscale network’s DNS server,
which may incur a higher latency if our rpi is not nearby.</p>

<h1 id="tls-certificates--the-green-stuff-">TLS Certificates ( The Green Stuff )</h1>

<p>To enable the use of HTTPS without encountering any browser warnings, obtaining TLS certificates is essential. If you
are already familiar with TLS and its intricacies, you may skip the remaining portion of this subsection. However, if
you require a more detailed explanation, there are numerous comprehensive resources available online.</p>

<p>TLS, which stands for Transport Layer Security, is a crucial component of Private Key Infrastructure (PKI)
framework. When a client and server aim to establish a secure communication channel, the client must be aware of the
server’s public key. While the DNS server provides the IP address of <code class="language-plaintext highlighter-rouge">machineA.ctld</code>, it does not verify the legitimacy
of the server’s public key. TLS ensures that the key has not been tampered with or maliciously
altered during transit over the network. While communications between Tailscale (TS) devices are considered secure, the
broader internet cannot make such assumptions. Therefore, without the server’s public key, secure communication becomes
impossible. This is where TLS certificates come into play.</p>

<p>A TLS certificate is an attestation signed by a trusted entity known as a Certificate Authority (CA). It asserts that a
specific public key belongs to <code class="language-plaintext highlighter-rouge">machineA.ctld</code>. Understanding the three levels of TLS certificates is
important. First, the root certificate is a self-signed certificate that contains the public key of the CA. This root
certificate must be installed on all machines requiring TLS functionality for our custom TLD. The private key used to
sign the root certificate is typically kept offline in cold storage, as recovery from a compromised root key is
impossible,
eg you can’t sign a revocation if your private key cannot be trusted.</p>

<p>The intermediate certificate is signed by the root certificate and is responsible for signing leaf certificates. Unlike
the root certificate, the private key of the intermediate certificate is usually kept online since it is required to
sign leaf certificates. If an intermediate certificate becomes compromised or expires, the root private key can be
brought out of cold storage to issue a revocation.</p>

<p>The leaf or end certificate, which is presented by <code class="language-plaintext highlighter-rouge">machineA.ctld</code>, serves as proof that its public key is legitimate.
The
intermediate certificate has the authority to revoke leaf certificates if <code class="language-plaintext highlighter-rouge">machineA.ctld</code> exhibits malicious behavior.</p>

<p>TLS certificates can be generated by the CA and securely transferred to the server using methods like scp. This approach
is particularly useful for devices where running ACME (Automated Certificate Management Environment) properly is not
feasible. Or if the CA cannot establish bi-directional communication with the machine for some reason. ACME provides an
automated mechanism for generating certificate signing requests and validating the domain ownership to the CA.</p>

<p>By understanding these concepts, we can effectively utilize TLS certificates to establish secure and trusted
communication channels, ensuring the green lock symbol and seamless HTTPS functionality in our browsers.</p>

<h2 id="acme">ACME</h2>

<p>If you have previous experience with Let’s Encrypt or certbot, then you are likely familiar with the ACME (Automated
Certificate Management Environment) protocol. ACME is a collection of protocols that servers can employ to demonstrate
their ownership of domain names to Certificate Authorities (CAs) when requesting certificates. The primary purpose of a
certificate is to certify that machineA.ctld is indeed the owner of a specific public key.</p>

<p>ACME offers two verification methods, with the less commonly used method being DNS certification. In this approach, the
client server contacts the ACME server and claims ownership of machineA.ctld. The client server provides a
Certificate Signing Request (CSR) to the ACME server for signing. The ACME server then requests the client server to add
a specific string to the TXT section of the DNS record. If the server genuinely owns machineA.ctld and its authoritative
nameserver supports an API for managing domain records, the server can perform the required operation and have it
verified by the ACME server. However, as we are utilizing dnsmasq as our DNS server, the specific steps for performing
this operation are not within my expertise.</p>

<p>It is worth noting that the DNS certification method is less common compared to the alternative method, which involves
proving ownership through HTTP-based challenges. This method requires the server to respond to a challenge by placing a
designated file at a specified location on the web server. The ACME server then attempts to access the file to validate
ownership. This approach is generally more straightforward to implement and is not dependent on what API your DNS
provider happens to supply.</p>

<h2 id="step-ca">Step CA</h2>

<p>To proceed with setting up an ACME server on a Raspberry Pi, we can follow the guide provided
at https://smallstep.com/blog/build-a-tiny-ca-with-raspberry-pi-yubikey/. Although the guide incorporates using a
YubiKey for loading keys, it is not necessary for our purposes. However, adhering to proper security practices is always
recommended, and if you have access to YubiKeys, it can enhance the overall security of the setup. I get them for free
at work. There is an option to use the infnoise generator dongle, but we will opt because it costs too much and I don’t
get them for free at work. I recommend you use the same Raspberry Pi you’re hosting the ctld DNS off of. Note that the
ACME server will run on port 443, while the DNS server will operate on port 53, ensuring that there won’t be any
conflicts between the two services.</p>

<p>During the setup process, remember to modify the domain from <code class="language-plaintext highlighter-rouge">tinyca.internal</code> to a domain of your choice with
the <code class="language-plaintext highlighter-rouge">.ctld</code> extension, such as <code class="language-plaintext highlighter-rouge">ctldca.ctld</code>.</p>

<p>Once you have completed this step, you will be able to request TLS certificates for your custom domain, allowing you to
establish secure connections using HTTPS.</p>

<h2 id="install-the-root-cert">Install the root cert</h2>

<p>To ensure that your browser and servers recognize the custom TLD Certificate Authority (CA) and avoid any issues with
certificate verification, install the root certificate into the truststore of your devices. This step
will establish trust in the certificates issued by the custom CA.</p>

<p>To verify if the installation was successful, you can open a shell or command prompt and execute the
command <code class="language-plaintext highlighter-rouge">curl https://machinea.ctld</code>. If you encounter an error 60, it indicates that the CA is not recognized by your
machine, indicating a problem with the root certificate installation.</p>

<p>For convenience and ease of use, it is recommended to store the root certificate in a cloud drive or a similar storage
solution. This way, you can readily access and install it on new devices whenever necessary.</p>

<h2 id="requesting-a-cert">Requesting a cert</h2>

<p>You can refer to the guides provided at https://smallstep.com/docs/tutorials/acme-protocol-acme-clients/ for detailed
instructions on setting up various ACME clients. However, if you’re looking for a straightforward and user-friendly
option, I
recommend using acme.sh.</p>

<h3 id="some-pitfalls-in-cert-requesting">Some pitfalls in cert requesting</h3>

<p>I’ll probably split this off into separate guides when I get the chance.</p>

<h4 id="haproxy">HAProxy</h4>

<p>Certain reverse proxies, such as HAProxy, will want your leaf certificate private key and certificate in 1 file. You
might need to cat them together if using <code class="language-plaintext highlighter-rouge">acme.sh</code>. A reverse proxy may also hog port 80 and 443 which are needed to
do the ACME challenge. Remember to carve out a path to your ACME client. I have something like this for HAProxy:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># In /etc/haproxy/haproxy.cfg</span>
frontend public
    <span class="nb">bind</span> :::80 v4v6
    <span class="c"># Redirect requests to this path towards the ACME cleint instance on port 8888</span>
    acl letsencrypt-acl path_beg /.well-known/acme-challenge/
    use_backend letsencrypt-backend <span class="k">if </span>letsencrypt-acl
    
    <span class="c"># Set the certificate</span>
    <span class="nb">bind</span> :::443 v4v6 ssl crt /home/pi/.acme.sh/octoprint.aws.pem

<span class="c"># This is the acme.sh port</span>
backend letsencrypt-backend
        server letsencrypt 127.0.0.1:8888
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># In crontab
# Request certs, place them in /some/config/dir. Follow the guide for details on configuring this. 
0 * * * * /some/dir/acme.sh --cron --home "/some/config/dir/" --force --httpport 8888 

# Combine the privKey and the cert. Order matters here
1 * * * * cat /some/config/dir/machineA.ctld.key /some/config/dir/machineA.ctld.crt &gt; /some/config/dir/machineA.ctld.pem
</code></pre></div></div>

<p>You also need to reload the certificate cause HAProxy is too dumb to pick up that you edited it. Drop this script into
a file, edit your crontab to run it. Also maybe edit out the octoprint stuff:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> “<span class="o">==========================</span> SET SSL CERT <span class="o">==========================</span>“
<span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cat</span> /home/pi/.acme.sh/octoprint.aws.pem<span class="si">)</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"set ssl cert /home/pi/.acme.sh/octoprint.aws.pem &lt;&lt;</span><span class="se">\n</span><span class="si">$(</span><span class="nb">cat</span> /home/pi/.acme.sh/octoprint.aws.pem<span class="si">)</span><span class="se">\n</span><span class="s2">"</span> | socat tcp-connect:localhost:9999 -
<span class="nb">echo</span> “<span class="o">==========================</span> SHOW SSL CERT - before <span class="o">==========================</span>“
<span class="nb">echo</span> <span class="s2">"show ssl cert */home/pi/.acme.sh/octoprint.aws.pem"</span> | socat tcp-connect:localhost:9999 -
<span class="nb">echo</span> “<span class="o">==========================</span> COMMIT SSL CERT <span class="o">==========================</span>“
<span class="nb">echo</span> <span class="s2">"commit ssl cert /home/pi/.acme.sh/octoprint.aws.pem"</span> | socat tcp-connect:localhost:9999 -
<span class="nb">echo</span> “<span class="o">==========================</span> SHOW SSL CERT - after <span class="o">==========================</span>“
<span class="nb">echo</span> <span class="s2">"show ssl cert /home/pi/.acme.sh/octoprint.aws.pem"</span> | socat tcp-connect:localhost:9999 -
</code></pre></div></div>

<h4 id="homeassistant">HomeAssistant</h4>

<p>This one is a pain in the ass. Haven’t gotten this up and running yet. I’ll write another post to document this.</p>


    </div>
  </article>


  
    
    <br>
    <hr>
    <br>
    <ul class="list-disc pl-8"></ul>

    <!-- Adds related posts to the end of an article -->
    <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2>
    <p class="mb-2">Here are some more articles you might like to read next:</p>
  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/arduino-gps-notes/">Notes on Arduino GPS Library</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/osc-52-patch-for-vte-0425/">Mosh + Tmux + Copy Paste</a>
  </li>

<div id="giscus_thread" style="max-width: 1200px; margin: 0 auto;">
  <script>
    let giscusTheme = localStorage.getItem("theme");
    let giscusAttributes = {
        "src": "https://giscus.app/client.js",
        "data-repo": "andrewmzhang/andrewmzhang-2021",
        "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMzExNjA1NTM=",
        "data-category": "Comments",
        "data-category-id": "DIC_kwDOE70b6c4CWnht",
        "data-mapping": "title",
        "data-strict": "1",
        "data-reactions-enabled": "1",
        "data-emit-metadata": "0",
        "data-input-position": "bottom",
        "data-theme": giscusTheme,
        "data-lang": "en",
        "crossorigin": "anonymous",
        "async": "",
    };


    let giscusScript = document.createElement("script");
    Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
    document.getElementById("giscus_thread").appendChild(giscusScript);
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a>
</noscript>
</div>
</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 Andrew M. Zhang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.
Last updated: May 20, 2023.
      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
